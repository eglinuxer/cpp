# doit
本文档记录一些平时编程需要时常提醒自己的要点。

## 0. 设计专业的 C++ 程序
- 需求分析
  - 做什么？
  - 做成什么样？
- 项目设计
  - 怎么做？
    - 将总的程序分为子系统，包括子系统之间的界面和依赖关系，子系统之间的数据流，每个子系统的输入输出和通用线程模型。
    - 每个子系统的详情，包括类的细分，类的层次结构，数据结构，算法，具体的线程模型和错误处理细节。
- 设计原则
  - 抽象
    - 保持公开行为和接口不变，底层可以随意改动。
    - 接口与实现分离。
  - 重用
  - 多用组合，少用继承。

## 1. 基本语法
- 从 C++17 开始可以将数组存储在 shared_ptr 中，但是不能使用 make_shared<>()
    ```cpp
    std::shared_ptr<Employee[]> employees(new Employee[10]);
    ```
- 使用 auto 会去除引用和 const 限定符，从而创建副本，如果不需要副本可以使用 auto& 或者 const auto& 。
  - 使用 decltype 不会去除 const 限定符。
- 原始字符串
    ```cpp
    const char* str = R"(Line1
    Line2)";

    const char* str2 = R"===(jjjjR"()"jjjjj)===";
    ```

## 2. 编程原则
- 使用 const
  - 使用 const 保护参数
  - 使用 const 定义常量，替代 #define 的形式
- 使用引用
  - 按 const 引用传递参数
- 推荐把所有的数据成员都声明为 private，在需要的时候通过 public 的 set 和 get 访问。
- 数据成员的初始化推荐使用构造函数初始化器，就是在构造函数名称之后加冒号，然后初始化数据成员。
  - 如果构造函数只是初始化数据成员，那就没有必要使用构造函数，数据成员可以直接声明定义的时候初始化。
- 使用统一初始化可以阻止类型窄化。
- 当编写一个类时，最好对其进行独立的单元测试。
- 为字符串分配内存的正确方式是在实际字符所需的空间 + 1 。
    ```cpp
    char* result = new char[strlen(str) + 1];
    strcpy(result, str);
    ```
- 永远不要从函数中返回在基于栈的 string 上调用 c_str()，因为返回的是 const char* 指针，一旦 string 销毁，这个指针就失效了。
  - data() 返回 char*
- 多重继承可以用混入类优化
  - 表示这个类还可以做什么？-able
- 高内聚
  - 单一职责原则，不要将无关概念组合在一起。
- 低耦合
  - 将子系统设计为可单独重用的分立组件。
- 只要有可能，就应该设计范型数据结构与算法。
- 开闭原则
  - 对扩展开放，对修改关闭
- 如果在类中进行了动态内存分配，那就一定要提供自己的复制狗爪和赋值运算符，完成深拷贝。